## 寫在前面 
這裡不討論 bootloader, 這塊會跟硬件環境有關.

也不挖掘 linux kernel source.

會討論的只有, bootloader 載入 kernel image and/or initramfs 後發生的事情, 供初學
embedded 開發的人員問題處理的脈絡.

為了方便實驗, 我們使用 kvm 加速實驗過程, 減少實體機器帶來的複雜度.

## linux 開機必須品
要讓 linux 系統正常啟動, 必須準備以下 3 件東西 (除 bootloader 外)

* kernel image
* initial ram disk (initramfs)
* root file system (root fs)

Kernel image 通常放置著 linux kernel 中最重要而無法分離的如 scheduler, syscall,
memory management... 等部份.

Initramfs 是什麼呢? 開機過程需要跟硬件打交道才能完成, 但一般的 distro 無法限制
user 機器上的硬件組合, 又不可能將所有的 drivers 都 build-in 到 kernel
image 中, 這樣產生出來的 kernel image 可能會有上百 M 的大小! Hacker
們就想到了個折衷的方式, 將系統啟動時會用到的 drivers/modules 放到一個 image 中,
以 bootloader 載入到內存中, 並通知 kernel 去裡面找尋需要的 driver, 並在順利開機後,
釋放掉它佔用的內存空間.

Root fs 中放置的是 userland 所需的程序及庫, 所下的命令, 所執行的應用,
都放在裡面.

## 實驗 1
這個實驗利用系統上現有的 kernel image 啟動 kvm.

首先, 裝上 kvm

```bash
$ sudo apt-get install -y kvm
```

接著利用系統上的 kernel image 開機, 例如

```bash
$ sudo kvm -kernel /boot/vmlinuz-3.13.0-40-generic
```

如果 kvm 運作正常, linux kernel 應該會 panic, 顯示如下訊息

```
Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
```

因為我們並未提供 root fs 給 kvm, 所以當 (panic) 在這個地方是正常的.

## 實驗 2
這個實驗我們來做個最小的 root fs. 最小的 root fs 能有多小? 一個 helloworld
的大小

```C
/* helloworld.c */
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main()
{
    printf("Hello World, I am process %d\n", getpid());

    while(1);

    return 0;
}
```

產生執行檔並去掉不需要的資訊

```bash
$ gcc -o helloworld -static helloworld.c
$ strip helloworld
```

因為這個 rootfs 中不會放置其他的 libraries, 所以 helloworld 在 build
的過程中必須要下 -static, 去掉對其他 shared libraries 的相依. 確認一下執行檔無外
部相依

```bash
$ file helloworld
helloworld: ELF 64-bit LSB  executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=77ad829f9efc770969e757b467e4c0b066e37db9, not stripped
$ ldd helloworld
        not a dynamic executable
```

接下來產生 root fs. 如果是一般放在 disk 上的 root fs 可能會有 kernel 中無驅動,
mount 不上, 造成 boot 失敗的問題. 在這個實驗, 我們把 root fs 放在 initramfs
中. 前面提到過, initramfs 是由 bootloader (或是 kvm) 載入放在 RAM 中, 且格式與
kernel 中的 pagge cache 相同, kernel 要從中取用東西就會簡單得多, 少掉了如
SATA bus driver, SATA disk driver, file system 等需求.

要產生 initramfs, 需用到 cpio 指令

```bash
$ echo init | cpio -H newc -o | gzip -c >initramfs.img.gz
$ file initramfs.img.gz 
initramfs.img.gz: gzip compressed data, from Unix, last modified: Sun Nov  9 14:51:59 2014
```

配合系統上的 kernel image 及我們剛產生的 initramfs, 執行 kvm
```bash
$ sudo kvm -kernel /boot/vmlinuz-3.13.0-40-generic -initrd initramfs.img.gz -append init=/helloworld
```

如果順利的話, kvm 印出 "Hello World! I am process 1" 後停止, 因為 hellworld 是
userspace 的第一個 process, 因此 process ID 一定為 1. 加上
"-append init=/helloworld" 的原因是 default 的 init 命令名稱不叫
"helloworld", 所以我們必須明確指出執行檔的路徑.

##實驗 3
光印出 "Hello World" 沒什麼用處. 如果 root fs
開機後能有基本的命令行功能會有用得多. 實驗 3 我們用 [busybox](http://www.busybox.net)
來製作一個這樣的環境.

一般桌面環境下的命令大多是獨立的存在, 分散於多個包之中, 功能較為完整,
佔用的空間也相對大得多. Busybox 將這些命令重新實現, 去掉了不常用的部份,
並集中放置於一個執行檔中, 大大的縮簡了空間的需要.

Busybox 提供了跟 linux kernel 一樣的 config 界面用以在 build source code
前增/刪功能. 但為了簡化實驗步驟, 還是跟前例一樣利用系統現有的 binary.

```bash
$ file /bin/busybox
/bin/busybox: ELF 64-bit LSB  executable, x86-64, version 1 (SYSV), statically linked, for GNU/Linux 2.6.24, BuildID[sha1]=ae3cf83d83d4ed554fa7ba6d5f2b17c92c362710, stripped
```

通常來說, 因為 busybox 也會被用於 initramfs 之中, 所以一般的 distro 中 busybox
的 executable 會是跟上例一樣, 是 static linked.

準備 root fs 的內容

```bash
$ mkdir -p example3/bin && cd example3/
$ cp /bin/busybox bin
$ ln -s /bin/busybox /init
$ ln -s busybox /bin/sh
$ find | cpio -H newc -o | gzip -c >../initramfs.img.gz
```

Busybox 中集合的命令執行的方式有幾種, 我們這裡是創建 symlink 到 busybox 本身,
例如 /init 及 /bin/sh. 在執行時, busybox 會 check 命令行中命令的名稱,
決定要執行的功能. 另外 copy 多份及建立 hardlink 則是另外兩種方式.

啟動 kvm

```bash
$ sudo kvm -kernel /boot/vmlinuz-3.13.0-40-generic -initrd ../initramfs.img.gz
```

如果一切順利, 那 kvm 會啟動到 busybox 的提示訊息, 按下 enter 即可進到命令行.
但這時會發現很多功能都無法使用, 例如

```bash
$ mount
mount: no /proc/mounts
$ top
top: can't change directory to '/proc': No such file or directory
```

這是因為少 mount 了些重要的目錄

```bash
$ mkdir /proc /sys /dev
$ mount -t proc none /proc/
$ mount -t sysfs none /sys/
$ mount -t devtmpfs none /dev/
```

另外, busybox 命令的 symlink 也只建立了 /init, /bin/sh, 可利用 --install
參數將所有命令的 symlink 都產生出來

```bash
$ mkdir -p /sbin/ /usr/bin/ /usr/sbin/
$ busybox --install
```

經過以上步驟, root fs 的可用性就會大大的提高. 想讓將這些初始過程在啟動時自動執行,
可自行將上面的令命寫到 /etc/init.d/rcS 中並加上可執行屬性.

先前說過, initramfs 是用在 kernel 初始完, 準備好 mount root fs 所需環境的機會.
如果功能都 built-in 到了 kernel image 的話這個步驟其實可有可無, 去掉的話還可減少
boot 所需時間. 不過 initramfs 還可提供一個搞清楚 root fs mount 不上原因的環境,
用做系統救援非常的方便.

## 實驗 4
前面產生出來的 root fs 功能相當的有限, 當然, 如果是用在資源相當少的 embedded 環境,
配合些自己寫的 shell script, 基本上是足夠了.

但如果用在運算資源較豐富的環境下, 或是想完整重用 PC linux 上的開發經驗,
利用現有 distro 來產生 root fs 內容會是比較好的選擇. 另外, 一般來說用 distro
提供的 install CD/DVD 來安裝 root fs, 結果通常會有比較多用不上的 packages,
安裝過程也需要通過安裝界面交互.
如果能有方式以腳本自動化這個過程將能大大的減少管理的心力.

實驗 4 將說明如何以 debootstrap 命令產生 debian based root fs.

首先, 安裝 debootstrap

```bash
$ sudo apt-get install debootstrap
...
$ debootstrap 
I: usage: [OPTION]... <suite> <target> [<mirror> [<script>]]
I: Try `debootstrap --help' for more information.
E: You must specify a suite and a target.
```

suite 提的是特定 distro 的版本代號, 例如 debian 7.0 的是 wheezy, ubuntu 14.04
的代號是 trusty. target 是指產生出來的 root fs 要放置的目錄名稱. mirror 是
mirror site 的 url, 其他基本不用管.

在產生 root fs 內容前, 我們要先準備好 disk image, 將它 format 成 ext4 file system,
然後 mount 上, 用以放置 root fs 內容, 之後以 -hda 的參數告知 kvm 用這個 disk image 做為
root fs 運行系統.

首先, 產生 disk image 並 format 成 ext4 file system

```bash
$ truncate -s 1G rootfs.img
$ mkfs.ext4 ./rootfs.img
$ file 
rootfs.img: Linux rev 1.0 ext4 filesystem data, UUID=6bdf3f0c-4804-4525-a5e1-e9b8a98b62f4 (extents) (large files) (huge files)
```

truncate 能幫我們產生一個 sparse file, 告知 file system
不要預先為這個檔案配置空間.

接著 mount 上新產生的 root fs

```bash
$ mkdir rootfs/
$ sudo mount -o loop rootfs.img rootfs/
```

用 debootstrap 產生 root fs

```bash
$ sudo debootstrap wheezy rootfs/ http://ftp.cn.debian.org/debian
```

順利的話 (通常造成問題會是下載 packages 失敗或是磁盤空間不足), 在 rootfs/
目錄下會有個功能完整的 debian 7.0 root fs. 為免因 root 未設密碼造成開機後無法
login. 可以 passwd 指令去掉密碼

```bash
$ sudo passwd -R rootfs/ -d root
```

或是, 直接修改 /etc/shadow 也有相同的效果

```bash
$ sudo sed -e 's@root:[^:]*:@root::@' rootfs/etc/shadow
```

在給 kvm 使用 rootfs.img 前要記得先將 umount rootfs/

```bash
$ sudo umount rootfs/
```

接著利用系統上的 kernel image, initramfs.img.gz 及我們將產生出來的 root fs 開機
```bash
$ kvm -kernel /boot/vmlinuz-3.13.0-40-generic -initrd /boot/initrd.img-3.13.0-40-generic-hda rootfs.img
```

開機後, 就可以在 kvm 中自訂 root fs, 安裝你想要的 packages.

###chroot

以 kvm 執行完整啟動流程的方式可以驗証 root fs 功能, 但不好將 root fs
的自訂過程自動化. 改用 chroot 會是比較好的選擇.

在泛 UNIX 環境下都可以找到 chroot 指令, 用途是, 在執行特定命令前, 以 chroot
syscall 改變目前的 root fs, 讓新產生的 process 執行於指定的 root fs 環境.
舉例來說, 你的桌面系統可能是 fedora, 在 download 了 gentoo 的 stage3 tar
包後解壓, 並 chroot 到解壓後的目錄, 你操作的 distro 就不再是 fedora 而是 gentoo,
裝包時的指令也就不會是 yum 而是 emerge.

以實驗 4 來說, 當 rootfs/ 準備好之後, 可這麼自訂 root fs
```bash
$ sudo chroot rootfs/ apt-get install locales command-not-found bash-completion
```

將上面的命令集中放置於 shell script 中, 自訂義 root fs 的產生就能被自動化.
